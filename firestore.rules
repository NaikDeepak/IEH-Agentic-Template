rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {
    // Users can read and update their own user document.
    // They cannot change their role once it has been set.
    match /users/{userId} {
      // Allow authenticated users to read profiles for referral/social features
      // Allow reading own profile; prevent collection-wide harvesting
      allow get: if request.auth != null && request.auth.uid == userId;
      allow list: if false;

      // Allow creation of a user document with strict validation
      allow create: if request.auth != null
                    && request.auth.uid == userId
                    && request.resource.data.keys().hasOnly([
                      'uid',
                      'email',
                      'displayName',
                      'photoURL',
                      'role',
                      'last_login',
                      'created_at',
                      'updated_at',
                      'skills',
                      'parsed_data',
                      'embedding',
                      // Activity tracking
                      'status',
                      'lastActiveAt',
                      'expiresAt',
                      // Referral tracking
                      'referralCode',
                      'browniePoints',
                      'referredBy',
                      'referralRewarded',
                      'phoneVerified',
                      'linkedinVerified',
                      'rewardedAt'
                    ])
                    && request.resource.data.uid == request.auth.uid
                    && request.resource.data.email == request.auth.token.email
                    && (
                      request.resource.data.role == null
                      || request.resource.data.role in ['seeker', 'employer']
                    );

      // Only allow safe user-controlled fields to change; role is immutable once set
      allow update: if request.auth != null
                    && request.auth.uid == userId
                    && request.resource.data.diff(resource.data).changedKeys().hasOnly([
                      'displayName',
                      'photoURL',
                      'last_login',
                      'updated_at',
                      'skills',
                      'parsed_data',
                      'embedding',
                      // Activity tracking
                      'status',
                      'lastActiveAt',
                      'expiresAt',
                      // Referral tracking
                      'referralCode',
                      'browniePoints',
                      'referredBy',
                      'referralRewarded',
                      'phoneVerified',
                      'linkedinVerified',
                      'rewardedAt'
                    ])
                    && (resource.data.role == null
                        || !('role' in request.resource.data)
                        || request.resource.data.role == resource.data.role)
                    && ( !('embedding' in request.resource.data)
                         || (request.resource.data.embedding is list
                             && request.resource.data.embedding.size() == 768
                             && request.resource.data.embedding[0] is number
                             && request.resource.data.embedding[767] is number) )
                    // Validate expiresAt if present (max 4 days + 1 hour buffer)
                    && ( !('expiresAt' in request.resource.data)
                         || request.resource.data.expiresAt <= request.time + duration.value(4, 'd') + duration.value(1, 'h') );

      // Subcollections
      match /resumes/{resumeId} {
        allow read, write: if request.auth != null && request.auth.uid == userId;
      }
      match /skillGaps/{gapId} {
        allow read, write: if request.auth != null && request.auth.uid == userId;
      }
      match /assessments/{assessmentId} {
        allow read, write: if request.auth != null && request.auth.uid == userId;
      }
      match /shortlist/{shortlistId} {
        allow read, write: if request.auth != null && request.auth.uid == userId;
      }
    }

    // Jobs Collection
    match /jobs/{jobId} {
      // Require authentication to read jobs (protects against scraping)
      allow read: if request.auth != null;

      allow create: if request.auth != null
                    && request.auth.token.role == 'employer'
                    && request.resource.data.employer_id == request.auth.uid
                    && request.resource.data.title is string && request.resource.data.title.size() > 5
                    && request.resource.data.description is string && request.resource.data.description.size() > 20
                    && request.resource.data.keys().hasOnly([
                      'employer_id',
                      'title',
                      'description',
                      'skills',
                      'location',
                      'type',
                      'work_mode',
                      'salary_range',
                      'contactEmail',
                      'status',
                      'created_at',
                      'updated_at',
                      'embedding',
                      // Activity tracking
                      'lastActiveAt',
                      'expiresAt',
                      'experience',
                      'screening_questions',
                      'company_id',
                      'company_bio'
                    ])
                    && ( !('embedding' in request.resource.data)
                         || (request.resource.data.embedding is list
                             && request.resource.data.embedding.size() == 768
                             && request.resource.data.embedding[0] is number
                             && request.resource.data.embedding[767] is number) )
                    // validate status values on creation
                    && request.resource.data.status in ['active', 'passive', 'closed'];

      // Only the job owner (employer) can update the job
      allow update: if request.auth != null
                    && request.auth.token.role == 'employer'
                    && resource.data.employer_id == request.auth.uid
                    // restrict what can change
                    && request.resource.data.diff(resource.data).changedKeys().hasOnly([
                      'title',
                      'description',
                      'skills',
                      'location',
                      'type',
                      'work_mode',
                      'salary_range',
                      'contactEmail',
                      'status',
                      'updated_at',
                      'embedding',
                      // Activity tracking
                      'lastActiveAt',
                      'expiresAt',
                      'experience',
                      'screening_questions',
                      'company_id',
                      'company_bio'
                    ])
                    // employer_id is immutable
                    && ( !('employer_id' in request.resource.data)
                         || request.resource.data.employer_id == resource.data.employer_id )
                    // optional: validate status values if you use them
                    && ( !('status' in request.resource.data)
                         || request.resource.data.status in ['active', 'passive', 'closed'] )
                    // validate embedding shape if present
                    && ( !('embedding' in request.resource.data)
                         || (request.resource.data.embedding is list
                             && request.resource.data.embedding.size() == 768
                             && request.resource.data.embedding[0] is number
                             && request.resource.data.embedding[767] is number) )
                    // Validate expiresAt if present (max 4 days + 1 hour buffer)
                    && ( !('expiresAt' in request.resource.data)
                         || request.resource.data.expiresAt <= request.time + duration.value(4, 'd') + duration.value(1, 'h') );
    }

    // Applications Collection
    match /applications/{appId} {
      allow create: if request.auth != null
                    && request.auth.token.role == 'seeker'
                    // prevent arbitrary field injection
                    && request.resource.data.keys().hasOnly([
                      'candidate_id',
                      'candidate_name',
                      'candidate_role',
                      'job_id',
                      'employer_id',
                      'answers',
                      'match_score',
                      'status',
                      'applied_at',
                      'updated_at'
                    ])
                    // bind application to caller
                    && request.resource.data.candidate_id == request.auth.uid
                    // job must exist
                    && exists(/databases/$(database)/documents/jobs/$(request.resource.data.job_id))
                    // employer_id must match the job's employer_id
                    && request.resource.data.employer_id == get(/databases/$(database)/documents/jobs/$(request.resource.data.job_id)).data.employer_id;

      allow update: if request.auth != null
                    && request.auth.token.role == 'employer'
                    && get(/databases/$(database)/documents/jobs/$(resource.data.job_id)).data.employer_id == request.auth.uid
                    && request.resource.data.diff(resource.data).changedKeys().hasOnly(['status', 'updated_at']);

      allow read: if request.auth != null && (resource.data.candidate_id == request.auth.uid || request.auth.token.role == 'employer');
    }

    // Companies Collection
    match /companies/{companyId} {
      // Require authentication to read company profiles
      allow read: if request.auth != null;

      // Allow creation by authenticated employers
      allow create: if request.auth != null
                    && request.auth.token.role == 'employer'
                    && request.resource.data.employer_ids.hasAll([request.auth.uid]);

      // Allow updates by employers associated with the company.
      // Require that the caller is still an employer and prevent changes to employer_ids
      allow update: if request.auth != null
                    && request.auth.token.role == 'employer'
                    && resource.data.employer_ids.hasAny([request.auth.uid])
                    && request.resource.data.employer_ids == resource.data.employer_ids;
    }

    // Seeker Profiles Collection
    match /seeker_profiles/{userId} {
      allow read: if request.auth != null; 
      allow write: if request.auth != null && request.auth.uid == userId;
    }

    // Referral Codes Collection
    match /referralCodes/{code} {
      // Anyone authenticated can look up a code
      allow read: if request.auth != null;
      // Only the user who owns the code can create it, and it must point to their UID
      allow create: if request.auth != null && request.resource.data.uid == request.auth.uid;
    }

    // Ledger Collection
    match /ledger/{entryId} {
      // Users can only read their own ledger entries
      allow read: if request.auth != null && resource.data.uid == request.auth.uid;
      
      // Allow creation via client-side transaction
      // This is risky without a backend, but for this prototype we'll allow it 
      // with strict validation that the UID matches the auth user.
      allow create: if request.auth != null 
                    && request.resource.data.uid == request.auth.uid
                    && request.resource.data.keys().hasOnly(['uid', 'amount', 'type', 'metadata', 'timestamp'])
                    && request.resource.data.amount is number
                    && request.resource.data.type in ['referral_bonus', 'redemption', 'manual_adjustment'];
    }
  }
}
