rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {
    // Users can read and update their own user document.
    // They cannot change their role once it has been set.
    // Users Collection
    match /users/{userId} {
      // Only allow users to read their own profile document.
      // (If you need public profiles later, expose a separate `publicUsers` collection
      // or a callable/HTTP endpoint that returns a curated subset.)
      allow get: if request.auth != null && request.auth.uid == userId;
      allow list: if false; // No collection scanning

      // Allow creation of a user document with strict validation
      allow create: if request.auth != null
                    && request.auth.uid == userId
                    && request.resource.data.keys().hasOnly([
                      'uid',
                      'email',
                      'displayName',
                      'photoURL',
                      // 'role' is intentionally excluded: only Admin SDK / Cloud Functions can set it
                      'last_login',
                      'created_at',
                      'updated_at',
                      'skills',
                      'parsed_data',
                      'embedding',
                      // Activity tracking
                      'status',
                      'lastActiveAt',
                      'expiresAt',
                      // Referral tracking
                      'referralCode',
                      'browniePoints',
                      'referredBy',
                      'onboarded_at'
                    ])
                    && request.resource.data.uid == request.auth.uid
                    && request.resource.data.email == request.auth.token.email
                    // browniePoints must be 0 or absent on creation — only backend can grant points
                    && (!('browniePoints' in request.resource.data)
                        || request.resource.data.browniePoints == 0);

      // Only allow safe user-controlled fields to change
      allow update: if request.auth != null
                    && request.auth.uid == userId
                    && request.resource.data.diff(resource.data).changedKeys().hasOnly([
                      'displayName',
                      'photoURL',
                      'last_login',
                      'updated_at',
                      'skills',
                      'parsed_data',
                      'embedding',
                      // Activity tracking
                      'status',
                      'lastActiveAt',
                      'expiresAt',
                      // Referral tracking
                      'referralCode',
                      // browniePoints: client can ONLY decrease (spend/redeem); increases come from Admin SDK
                      'browniePoints',
                      // referredBy: only set once; client can write it but not change it once set
                      'referredBy',
                      'onboarded_at',
                      'employerRole'
                      // NOTE: phoneVerified, linkedinVerified, referralRewarded, rewardedAt, role
                      // are intentionally excluded — only Admin SDK / Cloud Functions can set them
                    ])
                    // Role is immutable once set (and cannot be elevated by client)
                    && !('role' in request.resource.data.diff(resource.data).changedKeys())
                    // referredBy is write-once: may only be set if previously null/absent,
                    // and must be a non-empty string. Cannot be changed once set.
                    && (
                      !('referredBy' in request.resource.data.diff(resource.data).changedKeys())
                      || (
                        ( !('referredBy' in resource.data) || resource.data.referredBy == null )
                        && request.resource.data.referredBy is string
                      )
                    )
                    // Brownie Points Security: client can only decrease, and never below zero.
                    // Increases (bonuses) must come from backend (Admin SDK).
                    && (
                      !('browniePoints' in request.resource.data.diff(resource.data).changedKeys())
                      || (
                        resource.data.browniePoints is number
                        && request.resource.data.browniePoints is number
                        && request.resource.data.browniePoints >= 0
                        && request.resource.data.browniePoints < resource.data.browniePoints
                      )
                    )
                    // Embedding validation
                    && ( !('embedding' in request.resource.data)
                         || (request.resource.data.embedding is list
                             && request.resource.data.embedding.size() == 768
                             && request.resource.data.embedding[0] is number
                             && request.resource.data.embedding[767] is number) )
                    // Validate expiresAt if present (max 4 days + 1 hour buffer)
                    && ( !('expiresAt' in request.resource.data)
                         || request.resource.data.expiresAt <= request.time + duration.value(4, 'd') + duration.value(1, 'h') );

      // Subcollections
      match /resumes/{resumeId} {
        allow read, write: if request.auth != null && request.auth.uid == userId;
      }
      match /skillGaps/{gapId} {
        allow read, write: if request.auth != null && request.auth.uid == userId;
      }
      match /assessments/{assessmentId} {
        allow read, write: if request.auth != null && request.auth.uid == userId;
      }
      match /shortlist/{shortlistId} {
        allow read, write: if request.auth != null && request.auth.uid == userId;
      }
    }

    // Jobs Collection
    match /jobs/{jobId} {
      // Require authentication to read jobs (protects against scraping)
      allow read: if request.auth != null;

      allow create: if request.auth != null
                    // SECURITY: Only trust server-issued custom claims for role check.
                    // The Firestore-doc role fallback was removed to prevent self-assignment exploits.
                    && request.auth.token.role == 'employer'
                    && request.resource.data.employer_id == request.auth.uid
                    && request.resource.data.title is string && request.resource.data.title.size() > 5
                    && request.resource.data.description is string && request.resource.data.description.size() > 20
                    && request.resource.data.keys().hasOnly([
                      'employer_id',
                      'title',
                      'description',
                      'skills',
                      'location',
                      'type',
                      'work_mode',
                      'salary_range',
                      'contactEmail',
                      'status',
                      'created_at',
                      'updated_at',
                      'embedding',
                      // Activity tracking
                      'lastActiveAt',
                      'expiresAt',
                      'experience',
                      'screening_questions',
                      'company_id',
                      'company_bio'
                    ])
                    && ( !('embedding' in request.resource.data)
                         || (request.resource.data.embedding is list
                             && request.resource.data.embedding.size() == 768
                             && request.resource.data.embedding[0] is number
                             && request.resource.data.embedding[767] is number) )
                    // validate status values on creation
                    && request.resource.data.status in ['active', 'passive', 'closed'];

      // Only the job owner (employer) can update the job
      allow update: if request.auth != null
                    // SECURITY: Only trust server-issued custom claims for role check.
                    && request.auth.token.role == 'employer'
                    && resource.data.employer_id == request.auth.uid
                    // restrict what can change
                    && request.resource.data.diff(resource.data).changedKeys().hasOnly([
                      'title',
                      'description',
                      'skills',
                      'location',
                      'type',
                      'work_mode',
                      'salary_range',
                      'contactEmail',
                      'status',
                      'updated_at',
                      'embedding',
                      // Activity tracking
                      'lastActiveAt',
                      'expiresAt',
                      'experience',
                      'screening_questions',
                      'company_id',
                      'company_bio'
                    ])
                    // employer_id is immutable
                    && ( !('employer_id' in request.resource.data)
                         || request.resource.data.employer_id == resource.data.employer_id )
                    // optional: validate status values if you use them
                    && ( !('status' in request.resource.data)
                         || request.resource.data.status in ['active', 'passive', 'closed'] )
                    // validate embedding shape if present
                    && ( !('embedding' in request.resource.data)
                         || (request.resource.data.embedding is list
                             && request.resource.data.embedding.size() == 768
                             && request.resource.data.embedding[0] is number
                             && request.resource.data.embedding[767] is number) )
                    // Validate expiresAt if present (max 4 days + 1 hour buffer)
                    && ( !('expiresAt' in request.resource.data)
                         || request.resource.data.expiresAt <= request.time + duration.value(4, 'd') + duration.value(1, 'h') );
    }

    // Applications Collection
    match /applications/{appId} {
      allow create: if request.auth != null
                    && request.auth.token.role == 'seeker'
                    // prevent arbitrary field injection
                    && request.resource.data.keys().hasOnly([
                      'candidate_id',
                      'candidate_name',
                      'candidate_role',
                      'job_id',
                      'employer_id',
                      'answers',
                      'match_score',
                      'status',
                      'applied_at',
                      'updated_at'
                    ])
                    // bind application to caller
                    && request.resource.data.candidate_id == request.auth.uid
                    // job must exist
                    && exists(/databases/$(database)/documents/jobs/$(request.resource.data.job_id))
                    // employer_id must match the job's employer_id
                    && request.resource.data.employer_id == get(/databases/$(database)/documents/jobs/$(request.resource.data.job_id)).data.employer_id;

      allow update: if request.auth != null
                    && request.auth.token.role == 'employer'
                    && get(/databases/$(database)/documents/jobs/$(resource.data.job_id)).data.employer_id == request.auth.uid
                    && request.resource.data.diff(resource.data).changedKeys().hasOnly(['status', 'updated_at']);

      allow read: if request.auth != null && (resource.data.candidate_id == request.auth.uid || request.auth.token.role == 'employer');
    }

    // Companies Collection
    match /companies/{companyId} {
      // Require authentication to read company profiles
      allow read: if request.auth != null;

      // Allow creation by authenticated employers
      allow create: if request.auth != null
                    && request.auth.token.role == 'employer'
                    && request.resource.data.employer_ids.hasAll([request.auth.uid]);

      // Allow updates by employers associated with the company.
      // Require that the caller is still an employer and prevent changes to employer_ids
      allow update: if request.auth != null
                    && request.auth.token.role == 'employer'
                    && resource.data.employer_ids.hasAny([request.auth.uid])
                    && request.resource.data.employer_ids == resource.data.employer_ids;
    }

    // Seeker Profiles Collection
    match /seeker_profiles/{userId} {
      allow read: if request.auth != null; 
      allow write: if request.auth != null && request.auth.uid == userId;
    }

    // Referral Codes Collection
    match /referralCodes/{code} {
      // Anyone authenticated can look up a code
      allow read: if request.auth != null;
      // Only the user who owns the code can create it, and it must point to their UID
      allow create: if request.auth != null && request.resource.data.uid == request.auth.uid;
    }

    // Ledger Collection
    match /ledger/{entryId} {
      // Users can only read their own ledger entries
      allow read: if request.auth != null && resource.data.uid == request.auth.uid;
      
      // Strict Ledger Creation Rules:
      // 1. User can only create entries for themselves.
      // 2. Only 'redemption' is allowed from the client (spending points).
      // 3. Amount must be negative (spending).
      // 4. 'referral_bonus' and 'manual_adjustment' are BLOCKED (must come from Admin SDK/Backend).
      allow create: if request.auth != null 
                    && request.resource.data.uid == request.auth.uid
                    && request.resource.data.keys().hasOnly(['uid', 'amount', 'type', 'metadata', 'timestamp'])
                    && request.resource.data.amount is number
                    && (
                      // Allow redemption (spending points) check for negative amount
                      (request.resource.data.type == 'redemption' && request.resource.data.amount < 0)
                    );
    }
  }
}
