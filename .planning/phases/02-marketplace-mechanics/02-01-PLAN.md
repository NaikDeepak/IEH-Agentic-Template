---
phase: 02-marketplace-mechanics
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [src/types/index.ts, src/lib/activity.ts, firestore.rules]
autonomous: true
must_haves:
  truths:
    - "Jobs have status (active/passive) and last_active_at timestamps"
    - "Users have status (active/passive) and last_active_at timestamps"
    - "Client activity (login, view) updates the timestamp in Firestore"
  artifacts:
    - path: "src/types/index.ts"
      provides: "Job and User interfaces with status fields"
    - path: "src/lib/activity.ts"
      provides: "Functions to update activity timestamps"
  key_links:
    - from: "src/lib/activity.ts"
      to: "firestore.rules"
      via: "write permission checks"
---

<objective>
Define the data model for the "Active System" and implement the client-side tracking logic.

Purpose: Foundation for the marketplace mechanics; enables tracking when users/jobs were last active.
Output: TypeScript definitions, Firestore rules, and a utility library for tracking activity.
</objective>

<execution_context>
@/Users/deepaknaik/.claude/get-shit-done/workflows/execute-plan.md
@/Users/deepaknaik/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-marketplace-mechanics/02-CONTEXT.md
@.planning/phases/02-marketplace-mechanics/02-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Define Data Model</name>
  <files>src/types/index.ts</files>
  <action>
    Create or update `src/types/index.ts` to include:
    1. `ActivityStatus` type ('active' | 'passive').
    2. `Job` interface with `status: ActivityStatus`, `lastActiveAt: Timestamp`, `expiresAt: Timestamp`.
    3. `UserProfile` interface with `status: ActivityStatus`, `lastActiveAt: Timestamp`, `expiresAt: Timestamp`.

    Ensure strict typing for these fields.
  </action>
  <verify>
    cat src/types/index.ts | grep "status: ActivityStatus"
  </verify>
  <done>
    Types are defined and exported.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement Client-Side Tracker</name>
  <files>src/lib/activity.ts</files>
  <action>
    Create `src/lib/activity.ts`.
    Implement two main functions:
    1. `trackUserActivity(userId: string)`: Updates `users/{userId}` with `lastActiveAt: serverTimestamp()` and recalculates `expiresAt` (now + 4 days).
    2. `trackJobActivity(jobId: string)`: Updates `jobs/{jobId}` with `lastActiveAt` and `expiresAt`.

    Implement debouncing (only write if last update was > 1 hour ago) to save writes, using `localStorage` to cache last write time.
  </action>
  <verify>
    Check file creation and ensure debouncing logic uses localStorage.
  </verify>
  <done>
    Functions exist and handle Firestore writes with debouncing.
  </done>
</task>

<task type="auto">
  <name>Task 3: Update Firestore Rules</name>
  <files>firestore.rules</files>
  <action>
    Update `firestore.rules` to allow authenticated users to:
    1. Update their own `lastActiveAt` and `expiresAt` fields.
    2. Update `lastActiveAt` and `expiresAt` on Jobs they own.

    Ensure they cannot modify these fields to arbitrary future dates (limit `expiresAt` to max 4 days from now).
  </action>
  <verify>
    grep "allow update" firestore.rules
  </verify>
  <done>
    Rules allow specific timestamp updates for owners.
  </done>
</task>

</tasks>

<verification>
Manual verification via unit tests or script (mocking Firestore) is ideal, but for this phase, code inspection of the rules and types is sufficient.
</verification>

<success_criteria>
- [ ] Types defined for ActivityStatus
- [ ] trackUserActivity function implemented with debounce
- [ ] trackJobActivity function implemented with debounce
- [ ] Firestore rules permit these updates
</success_criteria>

<output>
After completion, create `.planning/phases/02-marketplace-mechanics/02-01-SUMMARY.md`
</output>
