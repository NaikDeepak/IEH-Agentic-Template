---
phase: 03-semantic-matching
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - functions/index.js
  - src/lib/ai/search.ts
  - firestore.indexes.json
autonomous: true
must_haves:
  truths:
    - "Backend endpoint /jobs/search accepts filters (status=active)"
    - "Backend endpoint /candidates/search exists and returns results"
    - "Search results exclude passive/inactive entities"
    - "Firestore indexes support filtered vector search"
  artifacts:
    - path: "functions/index.js"
      provides: "Search endpoints"
      exports: ["searchJobsHandler", "searchCandidatesHandler"]
    - path: "src/lib/ai/search.ts"
      provides: "Frontend client for search"
      exports: ["searchJobs", "searchCandidates"]
  key_links:
    - from: "src/lib/ai/search.ts"
      to: "/api/candidates/search"
      via: "fetch"
---

<objective>
Establish the backend infrastructure for bi-directional semantic search by creating the candidate search endpoint and enforcing "Active System" filters on both job and candidate searches.

Purpose: Foundation for Phase 3. Enables frontend to query for talent and jobs using vector embeddings while respecting marketplace rules (hiding inactive items).
Output: Working API endpoints for `/jobs/search` (updated) and `/candidates/search` (new) with necessary Firestore index definitions.
</objective>

<execution_context>
@/Users/deepaknaik/.claude/get-shit-done/workflows/execute-plan.md
@/Users/deepaknaik/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/03-semantic-matching/03-CONTEXT.md
@functions/index.js
@src/lib/ai/search.ts
@firestore.indexes.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update Firestore Indexes for Filtered Vector Search</name>
  <files>firestore.indexes.json</files>
  <action>
    Add Composite Vector Indexes to `firestore.indexes.json` to support filtering by `status` and `role` during vector search.

    Required Indexes:
    1. Collection: `jobs`
       - Field: `status` (Ascending)
       - Field: `embedding` (Vector, 768, COSINE)

    2. Collection: `users`
       - Field: `role` (Ascending)
       - Field: `status` (Ascending)
       - Field: `embedding` (Vector, 768, COSINE)

    Note: Keep existing indexes. This enables queries like "Find nearest vectors WHERE status == 'active'".
  </action>
  <verify>cat firestore.indexes.json | grep -A 10 "status"</verify>
  <done>firestore.indexes.json contains vector indexes combined with scalar fields</done>
</task>

<task type="auto">
  <name>Task 2: Implement Candidate Search & Filters in Backend</name>
  <files>functions/index.js</files>
  <action>
    Refactor `functions/index.js` to support filtered vector search.

    1. Extract common vector search logic into a reusable helper `runVectorSearch(collection, queryVector, filters, limit)` within `index.js`.
       - Map `filters` to `structuredQuery.where` clauses (CompositeFilter if multiple).

    2. Update `searchJobsHandler`:
       - Enforce `status == 'active'` filter by default.
       - Use the helper.

    3. Create `searchCandidatesHandler`:
       - Input: `{ query, limit }`
       - Steps: Generate embedding -> Call `runVectorSearch` on `users` collection.
       - Filters: `role == 'seeker'` AND `status == 'active'`.
       - Output: JSON list of candidates (excluding sensitive fields like email/phone, return only public profile data).

    4. Register `app.post("/candidates/search", searchCandidatesHandler)` (and `/api/...` alias).
  </action>
  <verify>
    Create a test script `scripts/test-search-endpoints.js` that:
    1. Hits `/api/jobs/search` with a query
    2. Hits `/api/candidates/search` with a query
    (Mock the response or use dry-run if credentials missing, but verify code structure)
  </verify>
  <done>Functions export searchCandidatesHandler and enforce status filters</done>
</task>

<task type="auto">
  <name>Task 3: Update Frontend Search Client</name>
  <files>src/lib/ai/search.ts</files>
  <action>
    Update `src/lib/ai/search.ts` to expose the new capabilities.

    1. Define shared types for Search Results (id, matchScore, data).
    2. Update `searchJobs` to handle the response format.
    3. Add `searchCandidates(query: string, limit?: number)` function.
       - Fetches `/api/candidates/search`.
       - Returns typed Candidate objects.
  </action>
  <verify>grep "searchCandidates" src/lib/ai/search.ts</verify>
  <done>Client library supports both job and candidate search</done>
</task>

</tasks>

<verification>
Manual verification:
1. `npm run build` (backend) to check syntax.
2. Review `firestore.indexes.json` for correctness.
</verification>

<success_criteria>
- [ ] `firestore.indexes.json` updated with composite vector indexes
- [ ] `functions/index.js` contains `searchCandidatesHandler`
- [ ] Both search endpoints enforce `status == 'active'`
- [ ] `src/lib/ai/search.ts` provides client methods for both
</success_criteria>

<output>
After completion, create `.planning/phases/03-semantic-matching/03-01-SUMMARY.md`
</output>
